import*as PIXI from"pixi.js";import{Container,VERSION,Rectangle,Point,Graphics}from"pixi.js";/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */ /* global Reflect, Promise */var extendStatics=function(e,t){return extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var o in t)t.hasOwnProperty(o)&&(e[o]=t[o])},extendStatics(e,t)};function __extends(e,t){function o(){this.constructor=e}extendStatics(e,t),e.prototype=null===t?Object.create(t):(o.prototype=t.prototype,new o)}var __assign=function(){return __assign=Object.assign||function(e){for(var t,o=1,r=arguments.length;o<r;o++)for(var n in t=arguments[o],t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e},__assign.apply(this,arguments)};function __rest(o,n){var e={};for(var t in o)Object.prototype.hasOwnProperty.call(o,t)&&0>n.indexOf(t)&&(e[t]=o[t]);if(null!=o&&"function"==typeof Object.getOwnPropertySymbols)for(var r=0,t=Object.getOwnPropertySymbols(o);r<t.length;r++)0>n.indexOf(t[r])&&Object.prototype.propertyIsEnumerable.call(o,t[r])&&(e[t[r]]=o[t[r]]);return e}/**
 * @typedef ViewportTouch
 * @property {number} id
 * @property {PIXI.Point} last
*/ /**
 * handles all input for Viewport
 * @private
 */class InputManager{constructor(e){/**
         * list of active touches on viewport
         * @type {ViewportTouch[]}
         */this.viewport=e,this.touches=[],this.addListeners()}/**
     * add input listeners
     * @private
     */addListeners(){this.viewport.interactive=!0,this.viewport.forceHitArea||(this.viewport.hitArea=new Rectangle(0,0,this.viewport.worldWidth,this.viewport.worldHeight)),this.viewport.on("pointerdown",this.down,this),this.viewport.on("pointermove",this.move,this),this.viewport.on("pointerup",this.up,this),this.viewport.on("pointerupoutside",this.up,this),this.viewport.on("pointercancel",this.up,this),this.viewport.on("pointerout",this.up,this),this.wheelFunction=t=>this.handleWheel(t),this.viewport.options.divWheel.addEventListener("wheel",this.wheelFunction,{passive:this.viewport.options.passiveWheel}),this.isMouseDown=!1}/**
     * removes all event listeners from viewport
     * (useful for cleanup of wheel when removing viewport)
     */destroy(){this.viewport.options.divWheel.removeEventListener("wheel",this.wheelFunction)}/**
     * handle down events for viewport
     * @param {PIXI.interaction.InteractionEvent} event
     */down(e){if(!this.viewport.pause&&this.viewport.worldVisible){if("mouse"===e.data.pointerType?this.isMouseDown=!0:!this.get(e.data.pointerId)&&this.touches.push({id:e.data.pointerId,last:null}),1===this.count()){this.last=e.data.global.clone();// clicked event does not fire if viewport is decelerating or bouncing
const t=this.viewport.plugins.get("decelerate"),o=this.viewport.plugins.get("bounce");this.clickedAvailable=!(t&&t.isActive()||o&&o.isActive())}else this.clickedAvailable=!1;const t=this.viewport.plugins.down(e);t&&this.viewport.options.stopPropagation&&e.stopPropagation()}}/**
     * @param {number} change
     * @returns whether change exceeds threshold
     */checkThreshold(e){var t=Math.abs;return!!(t(e)>=this.viewport.threshold)}/**
     * handle move events for viewport
     * @param {PIXI.interaction.InteractionEvent} event
     */move(e){if(!this.viewport.pause&&this.viewport.worldVisible){const t=this.viewport.plugins.move(e);if(this.clickedAvailable){const t=e.data.global.x-this.last.x,o=e.data.global.y-this.last.y;(this.checkThreshold(t)||this.checkThreshold(o))&&(this.clickedAvailable=!1)}t&&this.viewport.options.stopPropagation&&e.stopPropagation()}}/**
     * handle up events for viewport
     * @param {PIXI.interaction.InteractionEvent} event
     */up(e){if(!this.viewport.pause&&this.viewport.worldVisible){"mouse"===e.data.pointerType&&(this.isMouseDown=!1),"mouse"!==e.data.pointerType&&this.remove(e.data.pointerId);const t=this.viewport.plugins.up(e);this.clickedAvailable&&0===this.count()&&(this.viewport.emit("clicked",{screen:this.last,world:this.viewport.toWorld(this.last),viewport:this}),this.clickedAvailable=!1),t&&this.viewport.options.stopPropagation&&e.stopPropagation()}}/**
     * gets pointer position if this.interaction is set
     * @param {WheelEvent} event
     * @return {PIXI.Point}
     */getPointerPosition(e){let t=new Point;return this.viewport.options.interaction?this.viewport.options.interaction.mapPositionToPoint(t,e.clientX,e.clientY):(t.x=e.clientX,t.y=e.clientY),t}/**
     * handle wheel events
     * @param {WheelEvent} event
     */handleWheel(e){if(!this.viewport.pause&&this.viewport.worldVisible){// only handle wheel events where the mouse is over the viewport
const t=this.viewport.toLocal(this.getPointerPosition(e));if(this.viewport.left<=t.x&&t.x<=this.viewport.right&&this.viewport.top<=t.y&&t.y<=this.viewport.bottom){const t=this.viewport.plugins.wheel(e);t&&e.preventDefault()}}}pause(){this.touches=[],this.isMouseDown=!1}/**
     * get touch by id
     * @param {number} id
     * @return {ViewportTouch}
     */get(e){for(let t of this.touches)if(t.id===e)return t;return null}/**
     * remove touch by number
     * @param {number} id
     */remove(e){for(let t=0;t<this.touches.length;t++)if(this.touches[t].id===e)return void this.touches.splice(t,1)}/**
     * @returns {number} count of mouse/touch pointers that are down on the viewport
     */count(){return(this.isMouseDown?1:0)+this.touches.length}}const PLUGIN_ORDER=["drag","pinch","wheel","follow","mouse-edges","decelerate","bounce","snap-zoom","clamp-zoom","snap","clamp"];/**
 * Use this to access current plugins or add user-defined plugins
 */class PluginManager{/**
     * instantiated by Viewport
     * @param {Viewport} viewport
     */constructor(e){this.viewport=e,this.list=[],this.plugins={}}/**
     * Inserts a named plugin or a user plugin into the viewport
     * default plugin order: 'drag', 'pinch', 'wheel', 'follow', 'mouse-edges', 'decelerate', 'bounce', 'snap-zoom', 'clamp-zoom', 'snap', 'clamp'
     * @param {string} name of plugin
     * @param {Plugin} plugin - instantiated Plugin class
     * @param {number} index to insert userPlugin (otherwise inserts it at the end)
     */add(e,t,o=PLUGIN_ORDER.length){this.plugins[e]=t;const n=PLUGIN_ORDER.indexOf(e);-1!==n&&PLUGIN_ORDER.splice(n,1),PLUGIN_ORDER.splice(o,0,e),this.sort()}/**
     * get plugin
     * @param {string} name of plugin
     * @return {Plugin}
     */get(e){return this.plugins[e]}/**
     * update all active plugins
     * @private
     * @param {number} elapsed type in milliseconds since last update
     */update(e){for(let t of this.list)t.update(e)}/**
     * resize all active plugins
     * @private
     */resize(){for(let e of this.list)e.resize()}/**
     * clamps and resets bounce and decelerate (as needed) after manually moving viewport
     */reset(){this.plugins.bounce&&(this.plugins.bounce.reset(),this.plugins.bounce.bounce()),this.plugins.decelerate&&this.plugins.decelerate.reset(),this.plugins.snap&&this.plugins.snap.reset(),this.plugins.clamp&&this.plugins.clamp.update(),this.plugins["clamp-zoom"]&&this.plugins["clamp-zoom"].clamp()}/**
     * removes installed plugin
     * @param {string} name of plugin (e.g., 'drag', 'pinch')
     */remove(e){this.plugins[e]&&(this.plugins[e]=null,this.viewport.emit(e+"-remove"),this.sort())}/**
     * pause plugin
     * @param {string} name of plugin (e.g., 'drag', 'pinch')
     */pause(e){this.plugins[e]&&this.plugins[e].pause()}/**
     * resume plugin
     * @param {string} name of plugin (e.g., 'drag', 'pinch')
     */resume(e){this.plugins[e]&&this.plugins[e].resume()}/**
     * sort plugins according to PLUGIN_ORDER
     * @private
     */sort(){this.list=[];for(let e of PLUGIN_ORDER)this.plugins[e]&&this.list.push(this.plugins[e])}/**
     * handle down for all plugins
     * @private
     * @param {PIXI.interaction.InteractionEvent} event
     * @returns {boolean}
     */down(e){let t=!1;for(let o of this.list)o.down(e)&&(t=!0);return t}/**
     * handle move for all plugins
     * @private
     * @param {PIXI.interaction.InteractionEvent} event
     * @returns {boolean}
     */move(e){let t=!1;for(let o of this.viewport.plugins.list)o.move(e)&&(t=!0);return t}/**
     * handle up for all plugins
     * @private
     * @param {PIXI.interaction.InteractionEvent} event
     * @returns {boolean}
     */up(e){let t=!1;for(let o of this.list)o.up(e)&&(t=!0);return t}/**
     * handle wheel event for all plugins
     * @private
     * @param {WheelEvent} event
     * @returns {boolean}
     */wheel(t){let e=!1;for(let o of this.list)o.wheel(t)&&(e=!0);return e}}/**
 * derive this class to create user-defined plugins
 */class Plugin{/**
     * @param {Viewport} parent
     */constructor(e){this.parent=e,this.paused=!1}/** called when plugin is removed */destroy(){}/**
     * handler for pointerdown PIXI event
     * @param {PIXI.interaction.InteractionEvent} event
     * @returns {boolean}
     */down(){return!1}/**
     * handler for pointermove PIXI event
     * @param {PIXI.interaction.InteractionEvent} event
     * @returns {boolean}
     */move(){return!1}/**
     * handler for pointerup PIXI event
     * @param {PIXI.interaction.InteractionEvent} event
     * @returns {boolean}
     */up(){return!1}/**
     * handler for wheel event on div
     * @param {WheelEvent} event
     * @returns {boolean}
     */wheel(){return!1}/**
     * called on each tick
     * @param {number} elapsed time in millisecond since last update
     */update(){}/** called when the viewport is resized */resize(){}/** called when the viewport is manually moved */reset(){}/** pause the plugin */pause(){this.paused=!0}/** un-pause the plugin */resume(){this.paused=!1}}/**
 * @typedef {object} LastDrag
 * @property {number} x
 * @property {number} y
 * @property {PIXI.Point} parent
 */ /**
 * @typedef DragOptions
 * @property {string} [direction=all] direction to drag
 * @property {boolean} [wheel=true] use wheel to scroll in y direction(unless wheel plugin is active)
 * @property {number} [wheelScroll=1] number of pixels to scroll with each wheel spin
 * @property {boolean} [reverse] reverse the direction of the wheel scroll
 * @property {(boolean|string)} [clampWheel=false] clamp wheel(to avoid weird bounce with mouse wheel)
 * @property {string} [underflow=center] where to place world if too small for screen
 * @property {number} [factor=1] factor to multiply drag to increase the speed of movement
 * @property {string} [mouseButtons=all] changes which mouse buttons trigger drag, use: 'all', 'left', right' 'middle', or some combination, like, 'middle-right'; you may want to set viewport.options.disableOnContextMenu if you want to use right-click dragging
 */const dragOptions={direction:"all",wheel:!0,wheelScroll:1,reverse:!1,clampWheel:!1,underflow:"center",factor:1,mouseButtons:"all"};/**
 * @private
 */class Drag extends Plugin{/**
     * @param {Viewport} parent
     * @param {DragOptions} options
     */constructor(e,t={}){super(e),this.options=Object.assign({},dragOptions,t),this.moved=!1,this.reverse=this.options.reverse?1:-1,this.xDirection=!this.options.direction||"all"===this.options.direction||"x"===this.options.direction,this.yDirection=!this.options.direction||"all"===this.options.direction||"y"===this.options.direction,this.parseUnderflow(),this.mouseButtons(this.options.mouseButtons)}/**
     * initialize mousebuttons array
     * @param {string} buttons
     */mouseButtons(e){this.mouse=e&&"all"!==e?[-1!==e.indexOf("left"),-1!==e.indexOf("middle"),-1!==e.indexOf("right")]:[!0,!0,!0]}parseUnderflow(){const e=this.options.underflow.toLowerCase();"center"===e?(this.underflowX=0,this.underflowY=0):(this.underflowX=-1===e.indexOf("left")?-1===e.indexOf("right")?0:1:-1,this.underflowY=-1===e.indexOf("top")?-1===e.indexOf("bottom")?0:1:-1)}/**
     * @param {PIXI.interaction.InteractionEvent} event
     * @returns {boolean}
     */checkButtons(e){const t="mouse"===e.data.pointerType,o=this.parent.input.count();return!(1!==o&&(!(1<o)||this.parent.plugins.get("pinch"))||t&&!this.mouse[e.data.button])}/**
     * @param {PIXI.interaction.InteractionEvent} event
     */down(e){return this.paused?void 0:this.checkButtons(e)?(this.last={x:e.data.global.x,y:e.data.global.y},this.current=e.data.pointerId,!0):void(this.last=null)}get active(){return this.moved}/**
     * @param {PIXI.interaction.InteractionEvent} event
     */move(e){if(!this.paused&&this.last&&this.current===e.data.pointerId){const t=e.data.global.x,o=e.data.global.y,n=this.parent.input.count();if(1===n||1<n&&!this.parent.plugins.get("pinch")){const e=t-this.last.x,n=o-this.last.y;if(this.moved||this.xDirection&&this.parent.input.checkThreshold(e)||this.yDirection&&this.parent.input.checkThreshold(n)){const e={x:t,y:o};return this.xDirection&&(this.parent.x+=(e.x-this.last.x)*this.options.factor),this.yDirection&&(this.parent.y+=(e.y-this.last.y)*this.options.factor),this.last=e,this.moved||this.parent.emit("drag-start",{screen:new Point(this.last.x,this.last.y),world:this.parent.toWorld(new Point(this.last.x,this.last.y)),viewport:this.parent}),this.moved=!0,this.parent.emit("moved",{viewport:this.parent,type:"drag"}),!0}}else this.moved=!1}}/**
     * @param {PIXI.interaction.InteractionEvent} event
     * @returns {boolean}
     */up(){const e=this.parent.input.touches;if(1===e.length){const t=e[0];return t.last&&(this.last={x:t.last.x,y:t.last.y},this.current=t.id),this.moved=!1,!0}if(this.last&&this.moved){const e=new Point(this.last.x,this.last.y);return this.parent.emit("drag-end",{screen:e,world:this.parent.toWorld(e),viewport:this.parent}),this.last=null,this.moved=!1,!0}}/**
     * @param {WheelEvent} event
     * @returns {boolean}
     */wheel(e){if(!this.paused&&this.options.wheel){const t=this.parent.plugins.get("wheel");if(!t)return this.xDirection&&(this.parent.x+=e.deltaX*this.options.wheelScroll*this.reverse),this.yDirection&&(this.parent.y+=e.deltaY*this.options.wheelScroll*this.reverse),this.options.clampWheel&&this.clamp(),this.parent.emit("wheel-scroll",this.parent),this.parent.emit("moved",this.parent),this.parent.options.passiveWheel||e.preventDefault(),!0}}resume(){this.last=null,this.paused=!1}clamp(){const e=this.parent.plugins.get("decelerate")||{};if("y"!==this.options.clampWheel)if(this.parent.screenWorldWidth<this.parent.screenWidth)switch(this.underflowX){case-1:this.parent.x=0;break;case 1:this.parent.x=this.parent.screenWidth-this.parent.screenWorldWidth;break;default:this.parent.x=(this.parent.screenWidth-this.parent.screenWorldWidth)/2;}else 0>this.parent.left?(this.parent.x=0,e.x=0):this.parent.right>this.parent.worldWidth&&(this.parent.x=-this.parent.worldWidth*this.parent.scale.x+this.parent.screenWidth,e.x=0);if("x"!==this.options.clampWheel)if(this.parent.screenWorldHeight<this.parent.screenHeight)switch(this.underflowY){case-1:this.parent.y=0;break;case 1:this.parent.y=this.parent.screenHeight-this.parent.screenWorldHeight;break;default:this.parent.y=(this.parent.screenHeight-this.parent.screenWorldHeight)/2;}else 0>this.parent.top&&(this.parent.y=0,e.y=0),this.parent.bottom>this.parent.worldHeight&&(this.parent.y=-this.parent.worldHeight*this.parent.scale.y+this.parent.screenHeight,e.y=0)}}/**
 * @typedef {object} PinchOptions
 * @property {boolean} [noDrag] disable two-finger dragging
 * @property {number} [percent=1.0] percent to modify pinch speed
 * @property {PIXI.Point} [center] place this point at center during zoom instead of center of two fingers
 */const pinchOptions={noDrag:!1,percent:1,center:null};class Pinch extends Plugin{/**
     * @private
     * @param {Viewport} parent
     * @param {PinchOptions} [options]
     */constructor(e,t={}){super(e),this.options=Object.assign({},pinchOptions,t)}down(){if(2<=this.parent.input.count())return this.active=!0,!0}move(t){var e=Math.sqrt,o=Math.pow;if(this.paused||!this.active)return;const n=t.data.global.x,i=t.data.global.y,r=this.parent.input.touches;if(2<=r.length){const a=r[0],s=r[1],p=a.last&&s.last?e(o(s.last.x-a.last.x,2)+o(s.last.y-a.last.y,2)):null;if(a.id===t.data.pointerId?a.last={x:n,y:i,data:t.data}:s.id===t.data.pointerId&&(s.last={x:n,y:i,data:t.data}),p){let t;const n={x:a.last.x+(s.last.x-a.last.x)/2,y:a.last.y+(s.last.y-a.last.y)/2};this.options.center||(t=this.parent.toLocal(n));const i=e(o(s.last.x-a.last.x,2)+o(s.last.y-a.last.y,2)),r=(i-p)/this.parent.screenWidth*this.parent.scale.x*this.options.percent;this.parent.scale.x+=r,this.parent.scale.y+=r,this.parent.emit("zoomed",{viewport:this.parent,type:"pinch"});const l=this.parent.plugins.get("clamp-zoom");if(l&&l.clamp(),this.options.center)this.parent.moveCenter(this.options.center);else{const e=this.parent.toGlobal(t);this.parent.x+=n.x-e.x,this.parent.y+=n.y-e.y,this.parent.emit("moved",{viewport:this.parent,type:"pinch"})}!this.options.noDrag&&this.lastCenter&&(this.parent.x+=n.x-this.lastCenter.x,this.parent.y+=n.y-this.lastCenter.y,this.parent.emit("moved",{viewport:this.parent,type:"pinch"})),this.lastCenter=n,this.moved=!0}else this.pinching||(this.parent.emit("pinch-start",this.parent),this.pinching=!0);return!0}}up(){if(this.pinching&&1>=this.parent.input.touches.length)return this.active=!1,this.lastCenter=null,this.pinching=!1,this.moved=!1,this.parent.emit("pinch-end",this.parent),!0}}/**
 * @typedef ClampOptions
 * @property {(number|boolean)} [left=false] clamp left; true = 0
 * @property {(number|boolean)} [right=false] clamp right; true = viewport.worldWidth
 * @property {(number|boolean)} [top=false] clamp top; true = 0
 * @property {(number|boolean)} [bottom=false] clamp bottom; true = viewport.worldHeight
 * @property {string} [direction] (all, x, or y) using clamps of [0, viewport.worldWidth/viewport.worldHeight]; replaces left/right/top/bottom if set
 * @property {string} [underflow=center] where to place world if too small for screen (e.g., top-right, center, none, bottomleft)
 */const clampOptions={left:!1,right:!1,top:!1,bottom:!1,direction:null,underflow:"center"};class Clamp extends Plugin{/**
     * @private
     * @param {Viewport} parent
     * @param {ClampOptions} [options]
     */constructor(e,t={}){super(e),this.options=Object.assign({},clampOptions,t),this.options.direction&&(this.options.left=!("x"!==this.options.direction&&"all"!==this.options.direction)||null,this.options.right=!("x"!==this.options.direction&&"all"!==this.options.direction)||null,this.options.top=!("y"!==this.options.direction&&"all"!==this.options.direction)||null,this.options.bottom=!("y"!==this.options.direction&&"all"!==this.options.direction)||null),this.parseUnderflow(),this.update()}parseUnderflow(){const e=this.options.underflow.toLowerCase();"none"===e?this.noUnderflow=!0:"center"===e?(this.underflowX=this.underflowY=0,this.noUnderflow=!1):(this.underflowX=-1===e.indexOf("left")?-1===e.indexOf("right")?0:1:-1,this.underflowY=-1===e.indexOf("top")?-1===e.indexOf("bottom")?0:1:-1,this.noUnderflow=!1)}/**
     * handle move events
     * @param {PIXI.interaction.InteractionEvent} event
     * @returns {boolean}
     */move(){return this.update(),!1}update(){if(this.paused)return;const e={x:this.parent.x,y:this.parent.y},t=this.parent.plugins.decelerate||{};if(null!==this.options.left||null!==this.options.right){let o=!1;if(!(this.parent.screenWorldWidth<this.parent.screenWidth))null!==this.options.left&&this.parent.left<(!0===this.options.left?0:this.options.left)&&(this.parent.x=-(!0===this.options.left?0:this.options.left)*this.parent.scale.x,t.x=0,o=!0),null!==this.options.right&&this.parent.right>(!0===this.options.right?this.parent.worldWidth:this.options.right)&&(this.parent.x=-(!0===this.options.right?this.parent.worldWidth:this.options.right)*this.parent.scale.x+this.parent.screenWidth,t.x=0,o=!0);else if(!this.noUnderflow)switch(this.underflowX){case-1:0!==this.parent.x&&(this.parent.x=0,o=!0);break;case 1:this.parent.x!==this.parent.screenWidth-this.parent.screenWorldWidth&&(this.parent.x=this.parent.screenWidth-this.parent.screenWorldWidth,o=!0);break;default:this.parent.x!==(this.parent.screenWidth-this.parent.screenWorldWidth)/2&&(this.parent.x=(this.parent.screenWidth-this.parent.screenWorldWidth)/2,o=!0);}o&&this.parent.emit("moved",{viewport:this.parent,original:e,type:"clamp-x"})}if(null!==this.options.top||null!==this.options.bottom){let o=!1;if(!(this.parent.screenWorldHeight<this.parent.screenHeight))null!==this.options.top&&this.parent.top<(!0===this.options.top?0:this.options.top)&&(this.parent.y=-(!0===this.options.top?0:this.options.top)*this.parent.scale.y,t.y=0,o=!0),null!==this.options.bottom&&this.parent.bottom>(!0===this.options.bottom?this.parent.worldHeight:this.options.bottom)&&(this.parent.y=-(!0===this.options.bottom?this.parent.worldHeight:this.options.bottom)*this.parent.scale.y+this.parent.screenHeight,t.y=0,o=!0);else if(!this.noUnderflow)switch(this.underflowY){case-1:0!==this.parent.y&&(this.parent.y=0,o=!0);break;case 1:this.parent.y!==this.parent.screenHeight-this.parent.screenWorldHeight&&(this.parent.y=this.parent.screenHeight-this.parent.screenWorldHeight,o=!0);break;default:this.parent.y!==(this.parent.screenHeight-this.parent.screenWorldHeight)/2&&(this.parent.y=(this.parent.screenHeight-this.parent.screenWorldHeight)/2,o=!0);}o&&this.parent.emit("moved",{viewport:this.parent,original:e,type:"clamp-y"})}}}/**
 * @typedef {object} ClampZoomOptions
 * @property {number} [minWidth] minimum width
 * @property {number} [minHeight] minimum height
 * @property {number} [maxWidth] maximum width
 * @property {number} [maxHeight] maximum height
 */const clampZoomOptions={minWidth:null,minHeight:null,maxWidth:null,maxHeight:null};class ClampZoom extends Plugin{/**
     * @private
     * @param {Viewport} parent
     * @param {ClampZoomOptions} [options]
     */constructor(e,t={}){super(e),this.options=Object.assign({},clampZoomOptions,t),this.clamp()}resize(){this.clamp()}clamp(){if(this.paused)return;let e=this.parent.worldScreenWidth,t=this.parent.worldScreenHeight;if(null!==this.options.minWidth&&e<this.options.minWidth){const o=this.parent.scale.x;this.parent.fitWidth(this.options.minWidth,!1,!1,!0),this.parent.scale.y*=this.parent.scale.x/o,e=this.parent.worldScreenWidth,t=this.parent.worldScreenHeight,this.parent.emit("zoomed",{viewport:this.parent,type:"clamp-zoom"})}if(null!==this.options.maxWidth&&e>this.options.maxWidth){const o=this.parent.scale.x;this.parent.fitWidth(this.options.maxWidth,!1,!1,!0),this.parent.scale.y*=this.parent.scale.x/o,e=this.parent.worldScreenWidth,t=this.parent.worldScreenHeight,this.parent.emit("zoomed",{viewport:this.parent,type:"clamp-zoom"})}if(null!==this.options.minHeight&&t<this.options.minHeight){const o=this.parent.scale.y;this.parent.fitHeight(this.options.minHeight,!1,!1,!0),this.parent.scale.x*=this.parent.scale.y/o,e=this.parent.worldScreenWidth,t=this.parent.worldScreenHeight,this.parent.emit("zoomed",{viewport:this.parent,type:"clamp-zoom"})}if(null!==this.options.maxHeight&&t>this.options.maxHeight){const e=this.parent.scale.y;this.parent.fitHeight(this.options.maxHeight,!1,!1,!0),this.parent.scale.x*=this.parent.scale.y/e,this.parent.emit("zoomed",{viewport:this.parent,type:"clamp-zoom"})}}}/**
 * @typedef {object} DecelerateOptions
 * @property {number} [friction=0.95] percent to decelerate after movement
 * @property {number} [bounce=0.8] percent to decelerate when past boundaries (only applicable when viewport.bounce() is active)
 * @property {number} [minSpeed=0.01] minimum velocity before stopping/reversing acceleration
 */const decelerateOptions={friction:.95,bounce:.8,minSpeed:.01};class Decelerate extends Plugin{/**
     * @private
     * @param {Viewport} parent
     * @param {DecelerateOptions} [options]
     */constructor(e,t={}){super(e),this.options=Object.assign({},decelerateOptions,t),this.saved=[],this.reset(),this.parent.on("moved",e=>this.moved(e))}destroy(){this.parent}down(){this.saved=[],this.x=this.y=!1}isActive(){return this.x||this.y}move(){if(!this.paused){const e=this.parent.input.count();(1===e||1<e&&!this.parent.plugins.get("pinch"))&&(this.saved.push({x:this.parent.x,y:this.parent.y,time:performance.now()}),60<this.saved.length&&this.saved.splice(0,30))}}moved(e){if(this.saved.length){const t=this.saved[this.saved.length-1];"clamp-x"===e.type?t.x===e.original.x&&(t.x=this.parent.x):"clamp-y"===e.type&&t.y===e.original.y&&(t.y=this.parent.y)}}up(){if(0===this.parent.input.count()&&this.saved.length){const e=performance.now();for(let t of this.saved)if(t.time>=e-100){const o=e-t.time;this.x=(this.parent.x-t.x)/o,this.y=(this.parent.y-t.y)/o,this.percentChangeX=this.percentChangeY=this.options.friction;break}}}/**
     * manually activate plugin
     * @param {object} options
     * @param {number} [options.x]
     * @param {number} [options.y]
     */activate(e){e=e||{},"undefined"!=typeof e.x&&(this.x=e.x,this.percentChangeX=this.options.friction),"undefined"!=typeof e.y&&(this.y=e.y,this.percentChangeY=this.options.friction)}update(e){var t=Math.abs;if(this.paused)return;let o;this.x&&(this.parent.x+=this.x*e,this.x*=this.percentChangeX,t(this.x)<this.options.minSpeed&&(this.x=0),o=!0),this.y&&(this.parent.y+=this.y*e,this.y*=this.percentChangeY,t(this.y)<this.options.minSpeed&&(this.y=0),o=!0),o&&this.parent.emit("moved",{viewport:this.parent,type:"decelerate"})}reset(){this.x=this.y=null}}var commonjsGlobal="undefined"==typeof globalThis?"undefined"==typeof window?"undefined"==typeof global?"undefined"==typeof self?{}:self:global:window:globalThis;function createCommonjsModule(e,t){return t={exports:{}},e(t,t.exports),t.exports}var penner=createCommonjsModule(function(e){var o=Math.asin,n=Math.sin,i=Math.cos,r=Math.PI,a=Math.sqrt,l=Math.pow,u=Math.abs;/*
	Copyright © 2001 Robert Penner
	All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, 
	are permitted provided that the following conditions are met:

	Redistributions of source code must retain the above copyright notice, this list of 
	conditions and the following disclaimer.
	Redistributions in binary form must reproduce the above copyright notice, this list 
	of conditions and the following disclaimer in the documentation and/or other materials 
	provided with the distribution.

	Neither the name of the author nor the names of contributors may be used to endorse 
	or promote products derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
	AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
	OF THE POSSIBILITY OF SUCH DAMAGE.
 */(function(){var s,p;p=function(t){return e.exports=t},s={linear:function(e,t,o,n){return o*e/n+t},easeInQuad:function(e,o,n,i){return n*(e/=i)*e+o},easeOutQuad:function(e,o,n,i){return-n*(e/=i)*(e-2)+o},easeInOutQuad:function(e,o,n,i){return 1>(e/=i/2)?n/2*e*e+o:-n/2*(--e*(e-2)-1)+o},easeInCubic:function(e,o,n,i){return n*(e/=i)*e*e+o},easeOutCubic:function(e,o,n,i){return n*((e=e/i-1)*e*e+1)+o},easeInOutCubic:function(e,o,n,i){return 1>(e/=i/2)?n/2*e*e*e+o:n/2*((e-=2)*e*e+2)+o},easeInQuart:function(e,o,n,i){return n*(e/=i)*e*e*e+o},easeOutQuart:function(e,o,n,i){return-n*((e=e/i-1)*e*e*e-1)+o},easeInOutQuart:function(e,o,n,i){return 1>(e/=i/2)?n/2*e*e*e*e+o:-n/2*((e-=2)*e*e*e-2)+o},easeInQuint:function(e,o,n,i){return n*(e/=i)*e*e*e*e+o},easeOutQuint:function(e,o,n,i){return n*((e=e/i-1)*e*e*e*e+1)+o},easeInOutQuint:function(e,o,n,i){return 1>(e/=i/2)?n/2*e*e*e*e*e+o:n/2*((e-=2)*e*e*e*e+2)+o},easeInSine:function(e,t,o,n){return-o*i(e/n*(r/2))+o+t},easeOutSine:function(e,t,o,i){return o*n(e/i*(r/2))+t},easeInOutSine:function(e,t,o,n){return-o/2*(i(r*e/n)-1)+t},easeInExpo:function(e,t,o,n){return 0===e?t:o*l(2,10*(e/n-1))+t},easeOutExpo:function(e,t,o,n){return e===n?t+o:o*(-l(2,-10*e/n)+1)+t},easeInOutExpo:function(e,o,n,i){return 1>(e/=i/2)?n/2*l(2,10*(e-1))+o:n/2*(-l(2,-10*--e)+2)+o},easeInCirc:function(e,o,n,i){return-n*(a(1-(e/=i)*e)-1)+o},easeOutCirc:function(e,o,n,i){return n*a(1-(e=e/i-1)*e)+o},easeInOutCirc:function(e,o,n,i){return 1>(e/=i/2)?-n/2*(a(1-e*e)-1)+o:n/2*(a(1-(e-=2)*e)+1)+o},easeInElastic:function(e,i,h,c){var d,g,m;if(m=1.70158,g=0,d=h,0===e);else if(1===(e/=c));return g||(g=.3*c),d<u(h)?(d=h,m=g/4):m=g/(2*r)*o(h/d),-(d*l(2,10*(e-=1))*n((e*c-m)*(2*r)/g))+i},easeOutElastic:function(e,i,h,c){var d,g,m;if(m=1.70158,g=0,d=h,0===e);else if(1===(e/=c));return g||(g=.3*c),d<u(h)?(d=h,m=g/4):m=g/(2*r)*o(h/d),d*l(2,-10*e)*n((e*c-m)*(2*r)/g)+h+i},easeInOutElastic:function(e,i,h,c){var d,g,m;if(m=1.70158,g=0,d=h,0===e);else if(2==(e/=c/2));return g||(g=c*(1.5*.3)),d<u(h)?(d=h,m=g/4):m=g/(2*r)*o(h/d),1>e?-.5*(d*l(2,10*(e-=1))*n((e*c-m)*(2*r)/g))+i:.5*(d*l(2,-10*(e-=1))*n((e*c-m)*(2*r)/g))+h+i},easeInBack:function(e,o,n,i,r){return void 0===r&&(r=1.70158),n*(e/=i)*e*((r+1)*e-r)+o},easeOutBack:function(e,o,n,i,r){return void 0===r&&(r=1.70158),n*((e=e/i-1)*e*((r+1)*e+r)+1)+o},easeInOutBack:function(e,o,n,i,r){return void 0===r&&(r=1.70158),1>(e/=i/2)?n/2*(e*e*(((r*=1.525)+1)*e-r))+o:n/2*((e-=2)*e*(((r*=1.525)+1)*e+r)+2)+o},easeInBounce:function(e,t,o,n){var i;return i=s.easeOutBounce(n-e,0,o,n),o-i+t},easeOutBounce:function(e,o,n,i){return(e/=i)<1/2.75?n*(7.5625*e*e)+o:e<2/2.75?n*(7.5625*(e-=1.5/2.75)*e+.75)+o:e<2.5/2.75?n*(7.5625*(e-=2.25/2.75)*e+.9375)+o:n*(7.5625*(e-=2.625/2.75)*e+.984375)+o},easeInOutBounce:function(e,t,o,n){var i;return e<n/2?(i=s.easeInBounce(2*e,0,o,n),.5*i+t):(i=s.easeOutBounce(2*e-n,0,o,n),.5*i+.5*o+t)}},p(s)}).call(commonjsGlobal)});/**
 * returns correct Penner equation using string or Function
 * @param {(function|string)} [ease]
 * @param {defaults} default penner equation to use if none is provided
 */function ease(e,t){if(!e)return penner[t];return"function"==typeof e?e:"string"==typeof e?penner[e]:void 0}/**
 * @typedef {options} BounceOptions
 * @property {string} [sides=all] all, horizontal, vertical, or combination of top, bottom, right, left (e.g., 'top-bottom-right')
 * @property {number} [friction=0.5] friction to apply to decelerate if active
 * @property {number} [time=150] time in ms to finish bounce
 * @property {string|function} [ease=easeInOutSine] ease function or name (see http://easings.net/ for supported names)
 * @property {string} [underflow=center] (top/bottom/center and left/right/center, or center) where to place world if too small for screen
 */const bounceOptions={sides:"all",friction:.5,time:150,ease:"easeInOutSine",underflow:"center"};class Bounce extends Plugin{/**
     * @private
     * @param {Viewport} parent
     * @param {BounceOptions} [options]
     * @fires bounce-start-x
     * @fires bounce.end-x
     * @fires bounce-start-y
     * @fires bounce-end-y
     */constructor(e,t={}){super(e),this.options=Object.assign({},bounceOptions,t),this.ease=ease(this.options.ease,"easeInOutSine"),this.options.sides&&("all"===this.options.sides?this.top=this.bottom=this.left=this.right=!0:"horizontal"===this.options.sides?this.right=this.left=!0:"vertical"===this.options.sides?this.top=this.bottom=!0:(this.top=-1!==this.options.sides.indexOf("top"),this.bottom=-1!==this.options.sides.indexOf("bottom"),this.left=-1!==this.options.sides.indexOf("left"),this.right=-1!==this.options.sides.indexOf("right"))),this.parseUnderflow(),this.last={},this.reset()}parseUnderflow(){const e=this.options.underflow.toLowerCase();"center"===e?(this.underflowX=0,this.underflowY=0):(this.underflowX=-1===e.indexOf("left")?-1===e.indexOf("right")?0:1:-1,this.underflowY=-1===e.indexOf("top")?-1===e.indexOf("bottom")?0:1:-1)}isActive(){return null!==this.toX||null!==this.toY}down(){this.toX=this.toY=null}up(){this.bounce()}update(e){if(!this.paused){if(this.bounce(),this.toX){const t=this.toX;t.time+=e,this.parent.emit("moved",{viewport:this.parent,type:"bounce-x"}),t.time>=this.options.time?(this.parent.x=t.end,this.toX=null,this.parent.emit("bounce-x-end",this.parent)):this.parent.x=this.ease(t.time,t.start,t.delta,this.options.time)}if(this.toY){const t=this.toY;t.time+=e,this.parent.emit("moved",{viewport:this.parent,type:"bounce-y"}),t.time>=this.options.time?(this.parent.y=t.end,this.toY=null,this.parent.emit("bounce-y-end",this.parent)):this.parent.y=this.ease(t.time,t.start,t.delta,this.options.time)}}}calcUnderflowX(){let e;switch(this.underflowX){case-1:e=0;break;case 1:e=this.parent.screenWidth-this.parent.screenWorldWidth;break;default:e=(this.parent.screenWidth-this.parent.screenWorldWidth)/2;}return e}calcUnderflowY(){let e;switch(this.underflowY){case-1:e=0;break;case 1:e=this.parent.screenHeight-this.parent.screenWorldHeight;break;default:e=(this.parent.screenHeight-this.parent.screenWorldHeight)/2;}return e}bounce(){if(this.paused)return;let e,t=this.parent.plugins.get("decelerate");t&&(t.x||t.y)&&(t.x&&t.percentChangeX===t.options.friction||t.y&&t.percentChangeY===t.options.friction)&&(e=this.parent.OOB(),(e.left&&this.left||e.right&&this.right)&&(t.percentChangeX=this.options.friction),(e.top&&this.top||e.bottom&&this.bottom)&&(t.percentChangeY=this.options.friction));const o=this.parent.plugins.get("drag")||{},n=this.parent.plugins.get("pinch")||{};if(t=t||{},!o.active&&!n.active&&(!this.toX||!this.toY)&&(!t.x||!t.y)){e=e||this.parent.OOB();const o=e.cornerPoint;if(!this.toX&&!t.x){let t=null;e.left&&this.left?t=this.parent.screenWorldWidth<this.parent.screenWidth?this.calcUnderflowX():0:e.right&&this.right&&(t=this.parent.screenWorldWidth<this.parent.screenWidth?this.calcUnderflowX():-o.x),null!==t&&this.parent.x!==t&&(this.toX={time:0,start:this.parent.x,delta:t-this.parent.x,end:t},this.parent.emit("bounce-x-start",this.parent))}if(!this.toY&&!t.y){let t=null;e.top&&this.top?t=this.parent.screenWorldHeight<this.parent.screenHeight?this.calcUnderflowY():0:e.bottom&&this.bottom&&(t=this.parent.screenWorldHeight<this.parent.screenHeight?this.calcUnderflowY():-o.y),null!==t&&this.parent.y!==t&&(this.toY={time:0,start:this.parent.y,delta:t-this.parent.y,end:t},this.parent.emit("bounce-y-start",this.parent))}}}reset(){this.toX=this.toY=null}}/**
 * @typedef SnapOptions
 * @property {boolean} [topLeft] snap to the top-left of viewport instead of center
 * @property {number} [friction=0.8] friction/frame to apply if decelerate is active
 * @property {number} [time=1000]
 * @property {string|function} [ease=easeInOutSine] ease function or name (see http://easings.net/ for supported names)
 * @property {boolean} [interrupt=true] pause snapping with any user input on the viewport
 * @property {boolean} [removeOnComplete] removes this plugin after snapping is complete
 * @property {boolean} [removeOnInterrupt] removes this plugin if interrupted by any user input
 * @property {boolean} [forceStart] starts the snap immediately regardless of whether the viewport is at the desired location
 */const snapOptions={topLeft:!1,friction:.8,time:1e3,ease:"easeInOutSine",interrupt:!0,removeOnComplete:!1,removeOnInterrupt:!1,forceStart:!1};class Snap extends Plugin{/**
     * @private
     * @param {Viewport} parent
     * @param {number} x
     * @param {number} y
     * @param {SnapOptions} [options]
     * @event snap-start(Viewport) emitted each time a snap animation starts
     * @event snap-restart(Viewport) emitted each time a snap resets because of a change in viewport size
     * @event snap-end(Viewport) emitted each time snap reaches its target
     * @event snap-remove(Viewport) emitted if snap plugin is removed
     */constructor(e,t,o,n={}){super(e),this.options=Object.assign({},snapOptions,n),this.ease=ease(n.ease,"easeInOutSine"),this.x=t,this.y=o,this.options.forceStart&&this.snapStart()}snapStart(){this.percent=0,this.snapping={time:0};const e=this.options.topLeft?this.parent.corner:this.parent.center;this.deltaX=this.x-e.x,this.deltaY=this.y-e.y,this.startX=e.x,this.startY=e.y,this.parent.emit("snap-start",this.parent)}wheel(){this.options.removeOnInterrupt&&this.parent.plugins.remove("snap")}down(){this.options.removeOnInterrupt?this.parent.plugins.remove("snap"):this.options.interrupt&&(this.snapping=null)}up(){if(0===this.parent.input.count()){const e=this.parent.plugins.get("decelerate");e&&(e.x||e.y)&&(e.percentChangeX=e.percentChangeY=this.options.friction)}}update(e){if(!this.paused&&!(this.options.interrupt&&0!==this.parent.input.count()))if(!this.snapping){const e=this.options.topLeft?this.parent.corner:this.parent.center;(e.x!==this.x||e.y!==this.y)&&this.snapStart()}else{const t=this.snapping;t.time+=e;let o,n,i;if(t.time>this.options.time)o=!0,n=this.startX+this.deltaX,i=this.startY+this.deltaY;else{const e=this.ease(t.time,0,1,this.options.time);n=this.startX+this.deltaX*e,i=this.startY+this.deltaY*e}this.options.topLeft?this.parent.moveCorner(n,i):this.parent.moveCenter(n,i),this.parent.emit("moved",{viewport:this.parent,type:"snap"}),o&&(this.options.removeOnComplete&&this.parent.plugins.remove("snap"),this.parent.emit("snap-end",this.parent),this.snapping=null)}}}/**
 * @typedef {Object} SnapZoomOptions
 * @property {number} [width=0] the desired width to snap (to maintain aspect ratio, choose only width or height)
 * @property {number} [height=0] the desired height to snap (to maintain aspect ratio, choose only width or height)
 * @property {number} [time=1000] time for snapping in ms
 * @property {(string|function)} [ease=easeInOutSine] ease function or name (see http://easings.net/ for supported names)
 * @property {PIXI.Point} [center] place this point at center during zoom instead of center of the viewport
 * @property {boolean} [interrupt=true] pause snapping with any user input on the viewport
 * @property {boolean} [removeOnComplete] removes this plugin after snapping is complete
 * @property {boolean} [removeOnInterrupt] removes this plugin if interrupted by any user input
 * @property {boolean} [forceStart] starts the snap immediately regardless of whether the viewport is at the desired zoom
 * @property {boolean} [noMove] zoom but do not move
 */const snapZoomOptions={width:0,height:0,time:1e3,ease:"easeInOutSine",center:null,interrupt:!0,removeOnComplete:!1,removeOnInterrupts:!1,forceStart:!1,noMove:!1};class SnapZoom extends Plugin{/**
     * @param {Viewport} parent
     * @param {SnapZoomOptions} options
     * @event snap-zoom-start(Viewport) emitted each time a fit animation starts
     * @event snap-zoom-end(Viewport) emitted each time fit reaches its target
     * @event snap-zoom-end(Viewport) emitted each time fit reaches its target
     */constructor(e,t={}){super(e),this.options=Object.assign({},snapZoomOptions,t),this.ease=ease(this.options.ease),0<this.options.width&&(this.x_scale=e.screenWidth/this.options.width),0<this.options.height&&(this.y_scale=e.screenHeight/this.options.height),this.xIndependent=!!this.x_scale,this.yIndependent=!!this.y_scale,this.x_scale=this.xIndependent?this.x_scale:this.y_scale,this.y_scale=this.yIndependent?this.y_scale:this.x_scale,0===this.options.time?(e.container.scale.x=this.x_scale,e.container.scale.y=this.y_scale,this.options.removeOnComplete&&this.parent.plugins.remove("snap-zoom")):t.forceStart&&this.createSnapping()}createSnapping(){const e=this.parent.scale;this.snapping={time:0,startX:e.x,startY:e.y,deltaX:this.x_scale-e.x,deltaY:this.y_scale-e.y},this.parent.emit("snap-zoom-start",this.parent)}resize(){this.snapping=null,0<this.options.width&&(this.x_scale=this.parent._screenWidth/this.options.width),0<this.options.height&&(this.y_scale=this.parent._screenHeight/this.options.height),this.x_scale=this.xIndependent?this.x_scale:this.y_scale,this.y_scale=this.yIndependent?this.y_scale:this.x_scale}reset(){this.snapping=null}wheel(){this.options.removeOnInterrupt&&this.parent.plugins.remove("snap-zoom")}down(){this.options.removeOnInterrupt?this.parent.plugins.remove("snap-zoom"):this.options.interrupt&&(this.snapping=null)}update(e){if(this.paused)return;if(this.options.interrupt&&0!==this.parent.input.count())return;let t;if(this.options.center||this.options.noMove||(t=this.parent.center),!this.snapping)(this.parent.scale.x!==this.x_scale||this.parent.scale.y!==this.y_scale)&&this.createSnapping();else if(this.snapping){const o=this.snapping;if(o.time+=e,o.time>=this.options.time)this.parent.scale.set(this.x_scale,this.y_scale),this.options.removeOnComplete&&this.parent.plugins.remove("snap-zoom"),this.parent.emit("snap-zoom-end",this.parent),this.snapping=null;else{const e=this.snapping;this.parent.scale.x=this.ease(e.time,e.startX,e.deltaX,this.options.time),this.parent.scale.y=this.ease(e.time,e.startY,e.deltaY,this.options.time)}const n=this.parent.plugins.get("clamp-zoom");n&&n.clamp(),this.options.noMove||(this.options.center?this.parent.moveCenter(this.options.center):this.parent.moveCenter(t))}}resume(){this.snapping=null,super.resume()}}/**
 * @typedef {object} FollowOptions
 * @property {number} [speed=0] to follow in pixels/frame (0=teleport to location)
 * @property {number} [acceleration] set acceleration to accelerate and decelerate at this rate; speed cannot be 0 to use acceleration
 * @property {number} [radius] radius (in world coordinates) of center circle where movement is allowed without moving the viewport
 */const followOptions={speed:0,acceleration:null,radius:null};class Follow extends Plugin{/**
     * @private
     * @param {Viewport} parent
     * @param {PIXI.DisplayObject} target to follow
     * @param {FollowOptions} [options]
     */constructor(e,t,o={}){super(e),this.target=t,this.options=Object.assign({},followOptions,o),this.velocity={x:0,y:0}}update(e){var t=Math.max,o=Math.min,n=Math.atan2,i=Math.sin,r=Math.cos,a=Math.sqrt,s=Math.pow,p=Math.abs;if(this.paused)return;const l=this.parent.center;let d=this.target.x,c=this.target.y;if(this.options.radius){const e=a(s(this.target.y-l.y,2)+s(this.target.x-l.x,2));if(e>this.options.radius){const e=n(this.target.y-l.y,this.target.x-l.x);d=this.target.x-r(e)*this.options.radius,c=this.target.y-i(e)*this.options.radius}else return}const u=d-l.x,h=c-l.y;if(u||h)if(!this.options.speed)this.parent.moveCenter(d,c),this.parent.emit("moved",{viewport:this.parent,type:"follow"});else if(this.options.acceleration){const g=n(c-l.y,d-l.x),m=a(s(u,2)+s(h,2));if(m){const n=(s(this.velocity.x,2)+s(this.velocity.y,2))/(2*this.options.acceleration);this.velocity=m>n?{x:o(this.velocity.x+this.options.acceleration*e,this.options.speed),y:o(this.velocity.y+this.options.acceleration*e,this.options.speed)}:{x:t(this.velocity.x-this.options.acceleration*this.options.speed,0),y:t(this.velocity.y-this.options.acceleration*this.options.speed,0)};const a=r(g)*this.velocity.x,f=i(g)*this.velocity.y,w=p(a)>p(u)?d:l.x+a,x=p(f)>p(h)?c:l.y+f;this.parent.moveCenter(w,x),this.parent.emit("moved",{viewport:this.parent,type:"follow"})}}else{const e=n(c-l.y,d-l.x),t=r(e)*this.options.speed,o=i(e)*this.options.speed,a=p(t)>p(u)?d:l.x+t,s=p(o)>p(h)?c:l.y+o;this.parent.moveCenter(a,s),this.parent.emit("moved",{viewport:this.parent,type:"follow"})}}}/**
 * @typedef WheelOptions
 * @property {number} [percent=0.1] percent to scroll with each spin
 * @property {number} [smooth] smooth the zooming by providing the number of frames to zoom between wheel spins
 * @property {boolean} [interrupt=true] stop smoothing with any user input on the viewport
 * @property {boolean} [reverse] reverse the direction of the scroll
 * @property {PIXI.Point} [center] place this point at center during zoom instead of current mouse position
 */const wheelOptions={percent:.1,smooth:!1,interrupt:!0,reverse:!1,center:null};class Wheel extends Plugin{/**
     * @private
     * @param {Viewport} parent
     * @param {WheelOptions} [options]
     * @event wheel({wheel: {dx, dy, dz}, event, viewport})
     */constructor(e,t={}){super(e),this.options=Object.assign({},wheelOptions,t)}down(){this.options.interrupt&&(this.smoothing=null)}update(){if(this.smoothing){const e=this.smoothingCenter,t=this.smoothing;let o;this.options.center||(o=this.parent.toLocal(e)),this.parent.scale.x+=t.x,this.parent.scale.y+=t.y,this.parent.emit("zoomed",{viewport:this.parent,type:"wheel"});const n=this.parent.plugins.get("clamp-zoom");if(n&&n.clamp(),this.options.center)this.parent.moveCenter(this.options.center);else{const t=this.parent.toGlobal(o);this.parent.x+=e.x-t.x,this.parent.y+=e.y-t.y}this.smoothingCount++,this.smoothingCount>=this.options.smooth&&(this.smoothing=null)}}wheel(t){var e=Math.pow;if(this.paused)return;let o=this.parent.input.getPointerPosition(t);const n=this.options.reverse?-1:1,i=n*-t.deltaY*(t.deltaMode?120:1)/500,r=e(2,(1+this.options.percent)*i);if(this.options.smooth){const e={x:this.smoothing?this.smoothing.x*(this.options.smooth-this.smoothingCount):0,y:this.smoothing?this.smoothing.y*(this.options.smooth-this.smoothingCount):0};this.smoothing={x:((this.parent.scale.x+e.x)*r-this.parent.scale.x)/this.options.smooth,y:((this.parent.scale.y+e.y)*r-this.parent.scale.y)/this.options.smooth},this.smoothingCount=0,this.smoothingCenter=o}else{let e;this.options.center||(e=this.parent.toLocal(o)),this.parent.scale.x*=r,this.parent.scale.y*=r,this.parent.emit("zoomed",{viewport:this.parent,type:"wheel"});const t=this.parent.plugins.get("clamp-zoom");if(t&&t.clamp(),this.options.center)this.parent.moveCenter(this.options.center);else{const t=this.parent.toGlobal(e);this.parent.x+=o.x-t.x,this.parent.y+=o.y-t.y}}return(this.parent.emit("moved",{viewport:this.parent,type:"wheel"}),this.parent.emit("wheel",{wheel:{dx:t.deltaX,dy:t.deltaY,dz:t.deltaZ},event:t,viewport:this.parent}),!!!this.parent.options.passiveWheel)||void 0}}/**
 * @typedef MouseEdgesOptions
 * @property {number} [radius] distance from center of screen in screen pixels
 * @property {number} [distance] distance from all sides in screen pixels
 * @property {number} [top] alternatively, set top distance (leave unset for no top scroll)
 * @property {number} [bottom] alternatively, set bottom distance (leave unset for no top scroll)
 * @property {number} [left] alternatively, set left distance (leave unset for no top scroll)
 * @property {number} [right] alternatively, set right distance (leave unset for no top scroll)
 * @property {number} [speed=8] speed in pixels/frame to scroll viewport
 * @property {boolean} [reverse] reverse direction of scroll
 * @property {boolean} [noDecelerate] don't use decelerate plugin even if it's installed
 * @property {boolean} [linear] if using radius, use linear movement (+/- 1, +/- 1) instead of angled movement (Math.cos(angle from center), Math.sin(angle from center))
 * @property {boolean} [allowButtons] allows plugin to continue working even when there's a mousedown event
 */const mouseEdgesOptions={radius:null,distance:null,top:null,bottom:null,left:null,right:null,speed:8,reverse:!1,noDecelerate:!1,linear:!1,allowButtons:!1};class MouseEdges extends Plugin{/**
     * Scroll viewport when mouse hovers near one of the edges.
     * @private
     * @param {Viewport} parent
     * @param {MouseEdgeOptions} [options]
     * @event mouse-edge-start(Viewport) emitted when mouse-edge starts
     * @event mouse-edge-end(Viewport) emitted when mouse-edge ends
     */constructor(e,t={}){super(e),this.options=Object.assign({},mouseEdgesOptions,t),this.reverse=this.options.reverse?1:-1,this.radiusSquared=Math.pow(this.options.radius,2),this.resize()}resize(){const e=this.options.distance;null===e?!this.radius&&(this.left=this.options.left,this.top=this.options.top,this.right=null===this.options.right?null:this.parent.worldScreenWidth-this.options.right,this.bottom=null===this.options.bottom?null:this.parent.worldScreenHeight-this.options.bottom):(this.left=e,this.top=e,this.right=this.parent.worldScreenWidth-e,this.bottom=this.parent.worldScreenHeight-e)}down(){this.options.allowButtons||(this.horizontal=this.vertical=null)}move(e){var t=Math.round,o=Math.sin,n=Math.cos,i=Math.pow;if("mouse"!==e.data.pointerType&&1!==e.data.identifier||!this.options.allowButtons&&0!==e.data.buttons)return;const r=e.data.global.x,a=e.data.global.y;if(this.radiusSquared){const e=this.parent.toScreen(this.parent.center),s=i(e.x-r,2)+i(e.y-a,2);if(s>=this.radiusSquared){const i=Math.atan2(e.y-a,e.x-r);this.options.linear?(this.horizontal=t(n(i))*this.options.speed*this.reverse*(60/1e3),this.vertical=t(o(i))*this.options.speed*this.reverse*(60/1e3)):(this.horizontal=n(i)*this.options.speed*this.reverse*(60/1e3),this.vertical=o(i)*this.options.speed*this.reverse*(60/1e3))}else this.horizontal&&this.decelerateHorizontal(),this.vertical&&this.decelerateVertical(),this.horizontal=this.vertical=0}else null!==this.left&&r<this.left?this.horizontal=1*this.reverse*this.options.speed*(60/1e3):null!==this.right&&r>this.right?this.horizontal=-1*this.reverse*this.options.speed*(60/1e3):(this.decelerateHorizontal(),this.horizontal=0),null!==this.top&&a<this.top?this.vertical=1*this.reverse*this.options.speed*(60/1e3):null!==this.bottom&&a>this.bottom?this.vertical=-1*this.reverse*this.options.speed*(60/1e3):(this.decelerateVertical(),this.vertical=0)}decelerateHorizontal(){const e=this.parent.plugins.get("decelerate");this.horizontal&&e&&!this.options.noDecelerate&&e.activate({x:this.horizontal*this.options.speed*this.reverse/(1e3/60)})}decelerateVertical(){const e=this.parent.plugins.get("decelerate");this.vertical&&e&&!this.options.noDecelerate&&e.activate({y:this.vertical*this.options.speed*this.reverse/(1e3/60)})}up(){this.horizontal&&this.decelerateHorizontal(),this.vertical&&this.decelerateVertical(),this.horizontal=this.vertical=null}update(){if(!this.paused&&(this.horizontal||this.vertical)){const e=this.parent.center;this.horizontal&&(e.x+=this.horizontal*this.options.speed),this.vertical&&(e.y+=this.vertical*this.options.speed),this.parent.moveCenter(e),this.parent.emit("moved",{viewport:this.parent,type:"mouse-edges"})}}}/**
 * @typedef {object} ViewportOptions
 * @property {number} [screenWidth=window.innerWidth]
 * @property {number} [screenHeight=window.innerHeight]
 * @property {number} [worldWidth=this.width]
 * @property {number} [worldHeight=this.height]
 * @property {number} [threshold=5] number of pixels to move to trigger an input event (e.g., drag, pinch) or disable a clicked event
 * @property {boolean} [passiveWheel=true] whether the 'wheel' event is set to passive (note: if false, e.preventDefault() will be called when wheel is used over the viewport)
 * @property {boolean} [stopPropagation=false] whether to stopPropagation of events that impact the viewport (except wheel events, see options.passiveWheel)
 * @property {HitArea} [forceHitArea] change the default hitArea from world size to a new value
 * @property {boolean} [noTicker] set this if you want to manually call update() function on each frame
 * @property {PIXI.Ticker} [ticker=PIXI.Ticker.shared] use this PIXI.ticker for updates
 * @property {PIXI.InteractionManager} [interaction=null] InteractionManager, available from instantiated WebGLRenderer/CanvasRenderer.plugins.interaction - used to calculate pointer postion relative to canvas location on screen
 * @property {HTMLElement} [divWheel=document.body] div to attach the wheel event
 * @property {boolean} [disableOnContextMenu] remove oncontextmenu=() => {} from the divWheel element
 */const viewportOptions={screenWidth:window.innerWidth,screenHeight:window.innerHeight,worldWidth:null,worldHeight:null,threshold:5,passiveWheel:!0,stopPropagation:!1,forceHitArea:null,noTicker:!1,interaction:null,disableOnContextMenu:!1};/**
 * Main class to use when creating a Viewport
 */class Viewport extends Container{/**
     * @param {ViewportOptions} [options]
     * @fires clicked
     * @fires drag-start
     * @fires drag-end
     * @fires drag-remove
     * @fires pinch-start
     * @fires pinch-end
     * @fires pinch-remove
     * @fires snap-start
     * @fires snap-end
     * @fires snap-remove
     * @fires snap-zoom-start
     * @fires snap-zoom-end
     * @fires snap-zoom-remove
     * @fires bounce-x-start
     * @fires bounce-x-end
     * @fires bounce-y-start
     * @fires bounce-y-end
     * @fires bounce-remove
     * @fires wheel
     * @fires wheel-remove
     * @fires wheel-scroll
     * @fires wheel-scroll-remove
     * @fires mouse-edge-start
     * @fires mouse-edge-end
     * @fires mouse-edge-remove
     * @fires moved
     * @fires moved-end
     * @fires zoomed
     * @fires zoomed-end
     * @fires frame-end
     */constructor(e={}){// needed to pull this out of viewportOptions because of pixi.js v4 support (which changed from PIXI.ticker.shared to PIXI.Ticker.shared...sigh)
if(super(),this.options=Object.assign({},viewportOptions,e),e.ticker)this.options.ticker=e.ticker;else{// to avoid Rollup transforming our import, save pixi namespace in a variable
// from here: https://github.com/pixijs/pixi.js/issues/5757
let t;const o=PIXI;t=5>parseInt(/^(\d+)\./.exec(VERSION)[1])?o.ticker.shared:o.Ticker.shared,this.options.ticker=e.ticker||t}/** @type {number} */this.screenWidth=this.options.screenWidth,this.screenHeight=this.options.screenHeight,this._worldWidth=this.options.worldWidth,this._worldHeight=this.options.worldHeight,this.forceHitArea=this.options.forceHitArea,this.threshold=this.options.threshold,this.options.divWheel=this.options.divWheel||document.body,this.options.disableOnContextMenu&&(this.options.divWheel.oncontextmenu=t=>t.preventDefault()),this.options.noTicker||(this.tickerFunction=()=>this.update(this.options.ticker.elapsedMS),this.options.ticker.add(this.tickerFunction)),this.input=new InputManager(this),this.plugins=new PluginManager(this)}/**
     * overrides PIXI.Container's destroy to also remove the 'wheel' and PIXI.Ticker listeners
     * @param {(object|boolean)} [options] - Options parameter. A boolean will act as if all options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true. Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true. Should it destroy the base texture of the child sprite     */destroy(e){this.options.noTicker||this.options.ticker.remove(this.tickerFunction),this.input.destroy(),super.destroy(e)}/**
     * update viewport on each frame
     * by default, you do not need to call this unless you set options.noTicker=true
     * @param {number} elapsed time in milliseconds since last update
     */update(e){this.pause||(this.plugins.update(e),this.lastViewport&&(this.lastViewport.x!==this.x||this.lastViewport.y!==this.y?this.moving=!0:this.moving&&(this.emit("moved-end",this),this.moving=!1),this.lastViewport.scaleX!==this.scale.x||this.lastViewport.scaleY!==this.scale.y?this.zooming=!0:this.zooming&&(this.emit("zoomed-end",this),this.zooming=!1)),!this.forceHitArea&&(this._hitAreaDefault=new Rectangle(this.left,this.top,this.worldScreenWidth,this.worldScreenHeight),this.hitArea=this._hitAreaDefault),this._dirty=this._dirty||!this.lastViewport||this.lastViewport.x!==this.x||this.lastViewport.y!==this.y||this.lastViewport.scaleX!==this.scale.x||this.lastViewport.scaleY!==this.scale.y,this.lastViewport={x:this.x,y:this.y,scaleX:this.scale.x,scaleY:this.scale.y},this.emit("frame-end",this))}/**
     * use this to set screen and world sizes--needed for pinch/wheel/clamp/bounce
     * @param {number} [screenWidth=window.innerWidth]
     * @param {number} [screenHeight=window.innerHeight]
     * @param {number} [worldWidth]
     * @param {number} [worldHeight]
     */resize(e=window.innerWidth,t=window.innerHeight,o,n){this.screenWidth=e,this.screenHeight=t,"undefined"!=typeof o&&(this._worldWidth=o),"undefined"!=typeof n&&(this._worldHeight=n),this.plugins.resize()}/**
     * world width in pixels
     * @type {number}
     */get worldWidth(){return this._worldWidth?this._worldWidth:this.width/this.scale.x}set worldWidth(e){this._worldWidth=e,this.plugins.resize()}/**
     * world height in pixels
     * @type {number}
     */get worldHeight(){return this._worldHeight?this._worldHeight:this.height/this.scale.y}set worldHeight(e){this._worldHeight=e,this.plugins.resize()}/**
     * get visible bounds of viewport
     * @returns {PIXI.Rectangle}
     */getVisibleBounds(){return new Rectangle(this.left,this.top,this.worldScreenWidth,this.worldScreenHeight)}/**
     * change coordinates from screen to world
     * @param {(number|PIXI.Point)} x or point
     * @param {number} [y]
     * @return {PIXI.Point}
     */toWorld(e,t){return 2===arguments.length?this.toLocal(new Point(e,t)):this.toLocal(e)}/**
     * change coordinates from world to screen
     * @param {(number|PIXI.Point)} x or point
     * @param {number} [y]
     * @return {PIXI.Point}
     */toScreen(e,t){return 2===arguments.length?this.toGlobal(new Point(e,t)):this.toGlobal(e)}/**
     * screen width in world coordinates
     * @type {number}
     */get worldScreenWidth(){return this.screenWidth/this.scale.x}/**
     * screen height in world coordinates
     * @type {number}
     */get worldScreenHeight(){return this.screenHeight/this.scale.y}/**
     * world width in screen coordinates
     * @type {number}
     */get screenWorldWidth(){return this.worldWidth*this.scale.x}/**
     * world height in screen coordinates
     * @type {number}
     */get screenWorldHeight(){return this.worldHeight*this.scale.y}/**
     * center of screen in world coordinates
     * @type {PIXI.Point}
     */get center(){return new Point(this.worldScreenWidth/2-this.x/this.scale.x,this.worldScreenHeight/2-this.y/this.scale.y)}set center(e){this.moveCenter(e)}/**
     * move center of viewport to point
     * @param {(number|PIXI.Point)} x or point
     * @param {number} [y]
     * @return {Viewport} this
     */moveCenter(){let e,t;return isNaN(arguments[0])?(e=arguments[0].x,t=arguments[0].y):(e=arguments[0],t=arguments[1]),this.position.set((this.worldScreenWidth/2-e)*this.scale.x,(this.worldScreenHeight/2-t)*this.scale.y),this.plugins.reset(),this.dirty=!0,this}/**
     * top-left corner of Viewport
     * @type {PIXI.Point}
     */get corner(){return new Point(-this.x/this.scale.x,-this.y/this.scale.y)}set corner(e){this.moveCorner(e)}/**
     * move viewport's top-left corner; also clamps and resets decelerate and bounce (as needed)
     * @param {(number|PIXI.Point)} x or point
     * @param {number} [y]
     * @return {Viewport} this
     */moveCorner(e,t){return 1===arguments.length?this.position.set(-e.x*this.scale.x,-e.y*this.scale.y):this.position.set(-e*this.scale.x,-t*this.scale.y),this.plugins.reset(),this}/**
     * change zoom so the width fits in the viewport
     * @param {number} [width=this.worldWidth] in world coordinates
     * @param {boolean} [center] maintain the same center
     * @param {boolean} [scaleY=true] whether to set scaleY=scaleX
     * @param {boolean} [noClamp] whether to disable clamp-zoom
     * @returns {Viewport} this
     */fitWidth(e,t,o=!0,n){let i;t&&(i=this.center),this.scale.x=this.screenWidth/e,o&&(this.scale.y=this.scale.x);const r=this.plugins.get("clamp-zoom");return!n&&r&&r.clamp(),t&&this.moveCenter(i),this}/**
     * change zoom so the height fits in the viewport
     * @param {number} [height=this.worldHeight] in world coordinates
     * @param {boolean} [center] maintain the same center of the screen after zoom
     * @param {boolean} [scaleX=true] whether to set scaleX = scaleY
     * @param {boolean} [noClamp] whether to disable clamp-zoom
     * @returns {Viewport} this
     */fitHeight(e,t,o=!0,n){let i;t&&(i=this.center),this.scale.y=this.screenHeight/e,o&&(this.scale.x=this.scale.y);const r=this.plugins.get("clamp-zoom");return!n&&r&&r.clamp(),t&&this.moveCenter(i),this}/**
     * change zoom so it fits the entire world in the viewport
     * @param {boolean} center maintain the same center of the screen after zoom
     * @returns {Viewport} this
     */fitWorld(e){let t;e&&(t=this.center),this.scale.x=this.screenWidth/this.worldWidth,this.scale.y=this.screenHeight/this.worldHeight,this.scale.x<this.scale.y?this.scale.y=this.scale.x:this.scale.x=this.scale.y;const o=this.plugins.get("clamp-zoom");return o&&o.clamp(),e&&this.moveCenter(t),this}/**
     * change zoom so it fits the size or the entire world in the viewport
     * @param {boolean} [center] maintain the same center of the screen after zoom
     * @param {number} [width=this.worldWidth] desired width
     * @param {number} [height=this.worldHeight] desired height
     * @returns {Viewport} this
     */fit(e,t=this.worldWidth,o=this.worldHeight){let n;e&&(n=this.center),this.scale.x=this.screenWidth/t,this.scale.y=this.screenHeight/o,this.scale.x<this.scale.y?this.scale.y=this.scale.x:this.scale.x=this.scale.y;const i=this.plugins.get("clamp-zoom");return i&&i.clamp(),e&&this.moveCenter(n),this}/**
     * zoom viewport to specific value
     * @param {number} scale value (e.g., 1 would be 100%, 0.25 would be 25%)
     * @param {boolean} [center] maintain the same center of the screen after zoom
     * @return {Viewport} this
     */setZoom(e,t){let o;t&&(o=this.center),this.scale.set(e);const n=this.plugins.get("clamp-zoom");return n&&n.clamp(),t&&this.moveCenter(o),this}/**
     * zoom viewport by a certain percent (in both x and y direction)
     * @param {number} percent change (e.g., 0.25 would increase a starting scale of 1.0 to 1.25)
     * @param {boolean} [center] maintain the same center of the screen after zoom
     * @return {Viewport} this
     */zoomPercent(e,t){return this.setZoom(this.scale.x+this.scale.x*e,t)}/**
     * zoom viewport by increasing/decreasing width by a certain number of pixels
     * @param {number} change in pixels
     * @param {boolean} [center] maintain the same center of the screen after zoom
     * @return {Viewport} this
     */zoom(e,t){return this.fitWidth(e+this.worldScreenWidth,t),this}/**
     * changes scale of viewport and maintains center of viewport--same as calling setScale(scale, true)
     * @type {number}
     */set scaled(e){this.setZoom(e,!0)}get scaled(){return this.scale.x}/**
     * @param {SnapZoomOptions} options
     */snapZoom(e){return this.plugins.add("snap-zoom",new SnapZoom(this,e)),this}/**
     * is container out of world bounds
     * @returns {OutOfBounds}
     */OOB(){return{left:0>this.left,right:this.right>this._worldWidth,top:0>this.top,bottom:this.bottom>this._worldHeight,cornerPoint:new Point(this._worldWidth*this.scale.x-this.screenWidth,this._worldHeight*this.scale.y-this.screenHeight)}}/**
     * world coordinates of the right edge of the screen
     * @type {number}
     */get right(){return-this.x/this.scale.x+this.worldScreenWidth}set right(e){this.x=-e*this.scale.x+this.screenWidth,this.plugins.reset()}/**
     * world coordinates of the left edge of the screen
     * @type { number }
     */get left(){return-this.x/this.scale.x}set left(e){this.x=-e*this.scale.x,this.plugins.reset()}/**
     * world coordinates of the top edge of the screen
     * @type {number}
     */get top(){return-this.y/this.scale.y}set top(e){this.y=-e*this.scale.y,this.plugins.reset()}/**
     * world coordinates of the bottom edge of the screen
     * @type {number}
     */get bottom(){return-this.y/this.scale.y+this.worldScreenHeight}set bottom(e){this.y=-e*this.scale.y+this.screenHeight,this.plugins.reset()}/**
     * determines whether the viewport is dirty (i.e., needs to be renderered to the screen because of a change)
     * @type {boolean}
     */get dirty(){return this._dirty}set dirty(e){this._dirty=e}/**
     * permanently changes the Viewport's hitArea
     * NOTE: if not set then hitArea = PIXI.Rectangle(Viewport.left, Viewport.top, Viewport.worldScreenWidth, Viewport.worldScreenHeight)
     * @returns {HitArea}
     */get forceHitArea(){return this._forceHitArea}set forceHitArea(e){e?(this._forceHitArea=e,this.hitArea=e):(this._forceHitArea=null,this.hitArea=new Rectangle(0,0,this.worldWidth,this.worldHeight))}/**
     * enable one-finger touch to drag
     * NOTE: if you expect users to use right-click dragging, you should enable viewport.options.disableOnContextMenu to avoid the context menu popping up on each right-click drag
     * @param {DragOptions} [options]
     * @returns {Viewport} this
     */drag(e){return this.plugins.add("drag",new Drag(this,e)),this}/**
     * clamp to world boundaries or other provided boundaries
     * NOTES:
     *   clamp is disabled if called with no options; use { direction: 'all' } for all edge clamping
     *   screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
     * @param {ClampOptions} [options]
     * @returns {Viewport} this
     */clamp(e){return this.plugins.add("clamp",new Clamp(this,e)),this}/**
     * decelerate after a move
     * NOTE: this fires 'moved' event during deceleration
     * @param {DecelerateOptions} [options]
     * @return {Viewport} this
     */decelerate(e){return this.plugins.add("decelerate",new Decelerate(this,e)),this}/**
     * bounce on borders
     * NOTES:
     *    screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
     *    fires 'moved', 'bounce-x-start', 'bounce-y-start', 'bounce-x-end', and 'bounce-y-end' events
     * @param {object} [options]
     * @param {string} [options.sides=all] all, horizontal, vertical, or combination of top, bottom, right, left (e.g., 'top-bottom-right')
     * @param {number} [options.friction=0.5] friction to apply to decelerate if active
     * @param {number} [options.time=150] time in ms to finish bounce
     * @param {string|function} [options.ease=easeInOutSine] ease function or name (see http://easings.net/ for supported names)
     * @param {string} [options.underflow=center] (top/bottom/center and left/right/center, or center) where to place world if too small for screen
     * @return {Viewport} this
     */bounce(e){return this.plugins.add("bounce",new Bounce(this,e)),this}/**
     * enable pinch to zoom and two-finger touch to drag
     * @param {PinchOptions} [options]
     * @return {Viewport} this
     */pinch(e){return this.plugins.add("pinch",new Pinch(this,e)),this}/**
     * snap to a point
     * @param {number} x
     * @param {number} y
     * @param {SnapOptions} [options]
     * @return {Viewport} this
     */snap(e,t,o){return this.plugins.add("snap",new Snap(this,e,t,o)),this}/**
     * follow a target
     * NOTES:
     *    uses the (x, y) as the center to follow; for PIXI.Sprite to work properly, use sprite.anchor.set(0.5)
     *    options.acceleration is not perfect as it doesn't know the velocity of the target
     *    it adds acceleration to the start of movement and deceleration to the end of movement when the target is stopped
     *    fires 'moved' event
     * @param {PIXI.DisplayObject} target to follow
     * @param {FollowOptions} [options]
     * @returns {Viewport} this
     */follow(e,t){return this.plugins.add("follow",new Follow(this,e,t)),this}/**
     * zoom using mouse wheel
     * @param {WheelOptions} [options]
     * @return {Viewport} this
     */wheel(e){return this.plugins.add("wheel",new Wheel(this,e)),this}/**
     * enable clamping of zoom to constraints
     * @param {ClampZoomOptions} [options]
     * @return {Viewport} this
     */clampZoom(e){return this.plugins.add("clamp-zoom",new ClampZoom(this,e)),this}/**
     * Scroll viewport when mouse hovers near one of the edges or radius-distance from center of screen.
     * NOTE: fires 'moved' event
     * @param {MouseEdgesOptions} [options]
     */mouseEdges(e){return this.plugins.add("mouse-edges",new MouseEdges(this,e)),this}/**
     * pause viewport (including animation updates such as decelerate)
     * @type {boolean}
     */get pause(){return this._pause}set pause(e){this._pause=e,this.lastViewport=null,this.moving=!1,this.zooming=!1,e&&this.input.pause()}/**
     * move the viewport so the bounding box is visible
     * @param {number} x - left
     * @param {number} y - top
     * @param {number} width
     * @param {number} height
     */ensureVisible(e,t,o,n){e<this.left?this.left=e:e+o>this.right&&(this.right=e+o),t<this.top?this.top=t:t+n>this.bottom&&(this.bottom=t+n)}}var commonjsGlobal$1="undefined"==typeof globalThis?"undefined"==typeof window?"undefined"==typeof global?"undefined"==typeof self?{}:self:global:window:globalThis;function createCommonjsModule$1(e,t){return t={exports:{}},e(t,t.exports),t.exports}var penner$1=createCommonjsModule$1(function(e){var o=Math.asin,n=Math.sin,i=Math.cos,r=Math.PI,a=Math.sqrt,l=Math.pow,u=Math.abs;/*
	Copyright © 2001 Robert Penner
	All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, 
	are permitted provided that the following conditions are met:

	Redistributions of source code must retain the above copyright notice, this list of 
	conditions and the following disclaimer.
	Redistributions in binary form must reproduce the above copyright notice, this list 
	of conditions and the following disclaimer in the documentation and/or other materials 
	provided with the distribution.

	Neither the name of the author nor the names of contributors may be used to endorse 
	or promote products derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
	GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
	AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
	OF THE POSSIBILITY OF SUCH DAMAGE.
 */(function(){var s,p;p=function(t){return e.exports=t},s={linear:function(e,t,o,n){return o*e/n+t},easeInQuad:function(e,o,n,i){return n*(e/=i)*e+o},easeOutQuad:function(e,o,n,i){return-n*(e/=i)*(e-2)+o},easeInOutQuad:function(e,o,n,i){return 1>(e/=i/2)?n/2*e*e+o:-n/2*(--e*(e-2)-1)+o},easeInCubic:function(e,o,n,i){return n*(e/=i)*e*e+o},easeOutCubic:function(e,o,n,i){return n*((e=e/i-1)*e*e+1)+o},easeInOutCubic:function(e,o,n,i){return 1>(e/=i/2)?n/2*e*e*e+o:n/2*((e-=2)*e*e+2)+o},easeInQuart:function(e,o,n,i){return n*(e/=i)*e*e*e+o},easeOutQuart:function(e,o,n,i){return-n*((e=e/i-1)*e*e*e-1)+o},easeInOutQuart:function(e,o,n,i){return 1>(e/=i/2)?n/2*e*e*e*e+o:-n/2*((e-=2)*e*e*e-2)+o},easeInQuint:function(e,o,n,i){return n*(e/=i)*e*e*e*e+o},easeOutQuint:function(e,o,n,i){return n*((e=e/i-1)*e*e*e*e+1)+o},easeInOutQuint:function(e,o,n,i){return 1>(e/=i/2)?n/2*e*e*e*e*e+o:n/2*((e-=2)*e*e*e*e+2)+o},easeInSine:function(e,t,o,n){return-o*i(e/n*(r/2))+o+t},easeOutSine:function(e,t,o,i){return o*n(e/i*(r/2))+t},easeInOutSine:function(e,t,o,n){return-o/2*(i(r*e/n)-1)+t},easeInExpo:function(e,t,o,n){return 0===e?t:o*l(2,10*(e/n-1))+t},easeOutExpo:function(e,t,o,n){return e===n?t+o:o*(-l(2,-10*e/n)+1)+t},easeInOutExpo:function(e,o,n,i){return 1>(e/=i/2)?n/2*l(2,10*(e-1))+o:n/2*(-l(2,-10*--e)+2)+o},easeInCirc:function(e,o,n,i){return-n*(a(1-(e/=i)*e)-1)+o},easeOutCirc:function(e,o,n,i){return n*a(1-(e=e/i-1)*e)+o},easeInOutCirc:function(e,o,n,i){return 1>(e/=i/2)?-n/2*(a(1-e*e)-1)+o:n/2*(a(1-(e-=2)*e)+1)+o},easeInElastic:function(e,i,h,c){var d,g,m;if(m=1.70158,g=0,d=h,0===e);else if(1===(e/=c));return g||(g=.3*c),d<u(h)?(d=h,m=g/4):m=g/(2*r)*o(h/d),-(d*l(2,10*(e-=1))*n((e*c-m)*(2*r)/g))+i},easeOutElastic:function(e,i,h,c){var d,g,m;if(m=1.70158,g=0,d=h,0===e);else if(1===(e/=c));return g||(g=.3*c),d<u(h)?(d=h,m=g/4):m=g/(2*r)*o(h/d),d*l(2,-10*e)*n((e*c-m)*(2*r)/g)+h+i},easeInOutElastic:function(e,i,h,c){var d,g,m;if(m=1.70158,g=0,d=h,0===e);else if(2==(e/=c/2));return g||(g=c*(1.5*.3)),d<u(h)?(d=h,m=g/4):m=g/(2*r)*o(h/d),1>e?-.5*(d*l(2,10*(e-=1))*n((e*c-m)*(2*r)/g))+i:.5*(d*l(2,-10*(e-=1))*n((e*c-m)*(2*r)/g))+h+i},easeInBack:function(e,o,n,i,r){return void 0===r&&(r=1.70158),n*(e/=i)*e*((r+1)*e-r)+o},easeOutBack:function(e,o,n,i,r){return void 0===r&&(r=1.70158),n*((e=e/i-1)*e*((r+1)*e+r)+1)+o},easeInOutBack:function(e,o,n,i,r){return void 0===r&&(r=1.70158),1>(e/=i/2)?n/2*(e*e*(((r*=1.525)+1)*e-r))+o:n/2*((e-=2)*e*(((r*=1.525)+1)*e+r)+2)+o},easeInBounce:function(e,t,o,n){var i;return i=s.easeOutBounce(n-e,0,o,n),o-i+t},easeOutBounce:function(e,o,n,i){return(e/=i)<1/2.75?n*(7.5625*e*e)+o:e<2/2.75?n*(7.5625*(e-=1.5/2.75)*e+.75)+o:e<2.5/2.75?n*(7.5625*(e-=2.25/2.75)*e+.9375)+o:n*(7.5625*(e-=2.625/2.75)*e+.984375)+o},easeInOutBounce:function(e,t,o,n){var i;return e<n/2?(i=s.easeInBounce(2*e,0,o,n),.5*i+t):(i=s.easeOutBounce(2*e-n,0,o,n),.5*i+.5*o+t)}},p(s)}).call(commonjsGlobal$1)});const scrollboxOptions={boxWidth:100,boxHeight:100,scrollbarSize:10,scrollbarBackground:14540253,scrollbarBackgroundAlpha:1,scrollbarForeground:8947848,scrollbarForegroundAlpha:1,dragScroll:!0,stopPropagation:!0,scrollbarOffsetHorizontal:0,scrollbarOffsetVertical:0,underflow:"top-left",fadeScrollbar:!1,fadeScrollbarTime:1e3,fadeScrollboxWait:3e3,fadeScrollboxEase:"easeInOutSine",passiveWheel:!1,clampWheel:!0};/**
 * pixi.js scrollbox: a masked content box that can scroll vertically or horizontally with scrollbars
 */class Scrollbox extends Container{/**
     * create a scrollbox
     * @param {object} options
     * @param {boolean} [options.dragScroll=true] user may drag the content area to scroll content
     * @param {string} [options.overflowX=auto] (none, scroll, hidden, auto) this changes whether the scrollbar is shown
     * @param {string} [options.overflowY=auto] (none, scroll, hidden, auto) this changes whether the scrollbar is shown
     * @param {string} [options.overflow] (none, scroll, hidden, auto) sets overflowX and overflowY to this value
     * @param {number} [options.boxWidth=100] width of scrollbox including scrollbar (in pixels)
     * @param {number} [options.boxHeight=100] height of scrollbox including scrollbar (in pixels)
     * @param {number} [options.scrollbarSize=10] size of scrollbar (in pixels)
     * @param {number} [options.scrollbarOffsetHorizontal=0] offset of horizontal scrollbar (in pixels)
     * @param {number} [options.scrollbarOffsetVertical=0] offset of vertical scrollbar (in pixels)
     * @param {boolean} [options.stopPropagation=true] call stopPropagation on any events that impact scrollbox
     * @param {number} [options.scrollbarBackground=0xdddddd] background color of scrollbar
     * @param {number} [options.scrollbarBackgroundAlpha=1] alpha of background of scrollbar
     * @param {number} [options.scrollbarForeground=0x888888] foreground color of scrollbar
     * @param {number} [options.scrollbarForegroundAlpha=1] alpha of foreground of scrollbar
     * @param {string} [options.underflow=top-left] what to do when content underflows the scrollbox size: none: do nothing; (left/right/center AND top/bottom/center); OR center (e.g., 'top-left', 'center', 'none', 'bottomright')
     * @param {boolean} [options.noTicker] do not use PIXI.Ticker (for fade to work properly you will need to manually call updateLoop(elapsed) on each frame)
     * @param {PIXI.Ticker} [options.ticker=PIXI.Ticker.shared] use this PIXI.Ticker for updates
     * @param {boolean} [options.fade] fade the scrollbar when not in use
     * @param {number} [options.fadeScrollbarTime=1000] time to fade scrollbar if options.fade is set
     * @param {number} [options.fadeScrollboxWait=3000] time to wait before fading the scrollbar if options.fade is set
     * @param {(string|function)} [options.fadeScrollboxEase=easeInOutSine] easing function to use for fading
     * @param {boolean} [options.passiveWheel=false] whether wheel events are propogated beyond the scrollbox (NOTE: default is now false)
     * @param {boolean} [options.clampWheel=true] wheel events should be clamped (to avoid weird bounce with mouse wheel)
     */constructor(e={}){var t=Math.min;// needed to pull this out of viewportOptions because of pixi.js v4 support (which changed from PIXI.ticker.shared to PIXI.Ticker.shared...sigh)
if(super(),this.options=Object.assign({},scrollboxOptions,e),this.ease="function"==typeof this.options.fadeScrollboxEase?this.options.fadeScrollboxEase:penner$1[this.options.fadeScrollboxEase],this.content=this.addChild(new Viewport({passiveWheel:this.options.passiveWheel,stopPropagation:this.options.stopPropagation,screenWidth:this.options.boxWidth,screenHeight:this.options.boxHeight})),this.content.decelerate().on("moved",()=>this._drawScrollbars()),e.ticker)this.options.ticker=e.ticker;else{// to avoid Rollup transforming our import, save pixi namespace in a variable
// from here: https://github.com/pixijs/pixi.js/issues/5757
let t;const o=PIXI;t=5>parseInt(/^(\d+)\./.exec(VERSION)[1])?o.ticker.shared:o.Ticker.shared,this.options.ticker=e.ticker||t}/**
         * graphics element for drawing the scrollbars
         * @type {PIXI.Graphics}
         */this.scrollbar=this.addChild(new Graphics),this.scrollbar.interactive=!0,this.scrollbar.on("pointerdown",this.scrollbarDown,this),this.interactive=!0,this.on("pointermove",this.scrollbarMove,this),this.on("pointerup",this.scrollbarUp,this),this.on("pointercancel",this.scrollbarUp,this),this.on("pointerupoutside",this.scrollbarUp,this),this._maskContent=this.addChild(new Graphics),this.update(),this.options.noTicker||(this.tickerFunction=()=>this.updateLoop(t(this.options.ticker.elapsedMS,16.6667)),this.options.ticker.add(this.tickerFunction))}/**
     * offset of horizontal scrollbar (in pixels)
     * @type {number}
     */get scrollbarOffsetHorizontal(){return this.options.scrollbarOffsetHorizontal}set scrollbarOffsetHorizontal(e){this.options.scrollbarOffsetHorizontal=e}/**
     * offset of vertical scrollbar (in pixels)
     * @type {number}
     */get scrollbarOffsetVertical(){return this.options.scrollbarOffsetVertical}set scrollbarOffsetVertical(e){this.options.scrollbarOffsetVertical=e}/**
     * disable the scrollbox (if set to true this will also remove the mask)
     * @type {boolean}
     */get disable(){return this._disabled}set disable(e){this._disabled!==e&&(this._disabled=e,this.update())}/**
     * call stopPropagation on any events that impact scrollbox
     * @type {boolean}
     */get stopPropagation(){return this.options.stopPropagation}set stopPropagation(e){this.options.stopPropagation=e}/**
     * user may drag the content area to scroll content
     * @type {boolean}
     */get dragScroll(){return this.options.dragScroll}set dragScroll(e){this.options.dragScroll=e,e?this.content.drag():"undefined"==typeof this.content.removePlugin?this.content.plugins.remove("drag"):this.content.removePlugin("drag"),this.update()}/**
     * width of scrollbox including the scrollbar (if visible)- this changes the size and not the scale of the box
     * @type {number}
     */get boxWidth(){return this.options.boxWidth}set boxWidth(e){this.options.boxWidth=e,this.content.screenWidth=e,this.update()}/**
     * sets overflowX and overflowY to (scroll, hidden, auto) changing whether the scrollbar is shown
     * scroll = always show scrollbar
     * hidden = hide overflow and do not show scrollbar
     * auto = if content is larger than box size, then show scrollbar
     * @type {string}
     */get overflow(){return this.options.overflow}set overflow(e){this.options.overflow=e,this.options.overflowX=e,this.options.overflowY=e,this.update()}/**
     * sets overflowX to (scroll, hidden, auto) changing whether the scrollbar is shown
     * scroll = always show scrollbar
     * hidden = hide overflow and do not show scrollbar
     * auto = if content is larger than box size, then show scrollbar
     * @type {string}
     */get overflowX(){return this.options.overflowX}set overflowX(e){this.options.overflowX=e,this.update()}/**
     * sets overflowY to (scroll, hidden, auto) changing whether the scrollbar is shown
     * scroll = always show scrollbar
     * hidden = hide overflow and do not show scrollbar
     * auto = if content is larger than box size, then show scrollbar
     * @type {string}
     */get overflowY(){return this.options.overflowY}set overflowY(e){this.options.overflowY=e,this.update()}/**
     * height of scrollbox including the scrollbar (if visible) - this changes the size and not the scale of the box
     * @type {number}
     */get boxHeight(){return this.options.boxHeight}set boxHeight(e){this.options.boxHeight=e,this.content.screenHeight=e,this.update()}/**
     * scrollbar size in pixels
     * @type {number}
     */get scrollbarSize(){return this.options.scrollbarSize}set scrollbarSize(e){this.options.scrollbarSize=e}/**
     * width of scrollbox less the scrollbar (if visible)
     * @type {number}
     * @readonly
     */get contentWidth(){return this.options.boxWidth-(this.isScrollbarVertical?this.options.scrollbarSize:0)}/**
     * height of scrollbox less the scrollbar (if visible)
     * @type {number}
     * @readonly
     */get contentHeight(){return this.options.boxHeight-(this.isScrollbarHorizontal?this.options.scrollbarSize:0)}/**
     * is the vertical scrollbar visible
     * @type {boolean}
     * @readonly
     */get isScrollbarVertical(){return this._isScrollbarVertical}/**
     * is the horizontal scrollbar visible
     * @type {boolean}
     * @readonly
     */get isScrollbarHorizontal(){return this._isScrollbarHorizontal}/**
     * top coordinate of scrollbar
     */get scrollTop(){return this.content.top}/**
     * left coordinate of scrollbar
     */get scrollLeft(){return this.content.left}/**
     * width of content area
     * if not set then it uses content.width to calculate width
     */get scrollWidth(){return this._scrollWidth||this.content.width}set scrollWidth(e){this._scrollWidth=e}/**
     * height of content area
     * if not set then it uses content.height to calculate height
     */get scrollHeight(){return this._scrollHeight||this.content.height}set scrollHeight(e){this._scrollHeight=e}/**
     * draws scrollbars
     * @private
     */_drawScrollbars(){this._isScrollbarHorizontal=!("scroll"!==this.overflowX)||!(-1!==["hidden","none"].indexOf(this.overflowX))&&this.scrollWidth>this.options.boxWidth,this._isScrollbarVertical=!("scroll"!==this.overflowY)||!(-1!==["hidden","none"].indexOf(this.overflowY))&&this.scrollHeight>this.options.boxHeight,this.scrollbar.clear();({left:0,right:this.scrollWidth+(this._isScrollbarVertical?this.options.scrollbarSize:0),top:0,bottom:this.scrollHeight+(this.isScrollbarHorizontal?this.options.scrollbarSize:0)});const e=this.scrollWidth+(this.isScrollbarVertical?this.options.scrollbarSize:0),t=this.scrollHeight+(this.isScrollbarHorizontal?this.options.scrollbarSize:0);// this.content.forceHitArea = new PIXI.Rectangle(0, 0 , this.boxWidth, this.boxHeight)
this.scrollbarTop=this.content.top/t*this.boxHeight,this.scrollbarTop=0>this.scrollbarTop?0:this.scrollbarTop,this.scrollbarHeight=this.boxHeight/t*this.boxHeight,this.scrollbarHeight=this.scrollbarTop+this.scrollbarHeight>this.boxHeight?this.boxHeight-this.scrollbarTop:this.scrollbarHeight,this.scrollbarLeft=this.content.left/e*this.boxWidth,this.scrollbarLeft=0>this.scrollbarLeft?0:this.scrollbarLeft,this.scrollbarWidth=this.boxWidth/e*this.boxWidth,this.scrollbarWidth=this.scrollbarWidth+this.scrollbarLeft>this.boxWidth?this.boxWidth-this.scrollbarLeft:this.scrollbarWidth,this.isScrollbarVertical&&this.scrollbar.beginFill(this.options.scrollbarBackground,this.options.scrollbarBackgroundAlpha).drawRect(this.boxWidth-this.scrollbarSize+this.options.scrollbarOffsetVertical,0,this.scrollbarSize,this.boxHeight).endFill(),this.isScrollbarHorizontal&&this.scrollbar.beginFill(this.options.scrollbarBackground,this.options.scrollbarBackgroundAlpha).drawRect(0,this.boxHeight-this.scrollbarSize+this.options.scrollbarOffsetHorizontal,this.boxWidth,this.scrollbarSize).endFill(),this.isScrollbarVertical&&this.scrollbar.beginFill(this.options.scrollbarForeground,this.options.scrollbarForegroundAlpha).drawRect(this.boxWidth-this.scrollbarSize+this.options.scrollbarOffsetVertical,this.scrollbarTop,this.scrollbarSize,this.scrollbarHeight).endFill(),this.isScrollbarHorizontal&&this.scrollbar.beginFill(this.options.scrollbarForeground,this.options.scrollbarForegroundAlpha).drawRect(this.scrollbarLeft,this.boxHeight-this.scrollbarSize+this.options.scrollbarOffsetHorizontal,this.scrollbarWidth,this.scrollbarSize).endFill(),this.activateFade()}/**
     * draws mask layer
     * @private
     */_drawMask(){this._maskContent.beginFill(0).drawRect(0,0,this.boxWidth,this.boxHeight).endFill(),this.content.mask=this._maskContent}/**
     * call when scrollbox content changes
     */update(){if(this.content.mask=null,this._maskContent.clear(),!this._disabled&&(this._drawScrollbars(),this._drawMask(),this.options.dragScroll)){const e=this.isScrollbarHorizontal&&this.isScrollbarVertical?"all":this.isScrollbarHorizontal?"x":"y";null!==e&&this.content.drag({clampWheel:this.options.clampWheel,direction:e}).clamp({direction:e,underflow:this.options.underflow})}}/**
     * called on each frame to update fade scrollbars (if enabled)
     * @param {number} elapsed since last frame in milliseconds (usually capped at 16.6667)
     */updateLoop(e){if(this.fade){if(0<this.fade.wait)if(this.fade.wait-=e,0>=this.fade.wait)e+=this.fade.wait;else return;this.fade.duration+=e,this.fade.duration>=this.options.fadeScrollbarTime?(this.fade=null,this.scrollbar.alpha=0):this.scrollbar.alpha=this.ease(this.fade.duration,1,-1,this.options.fadeScrollbarTime),this.content.dirty=!0}}/**
     * dirty value (used for optimizing draws) for underlying viewport (scrollbox.content)
     * @type {boolean}
     */get dirty(){return this.content.dirty}set dirty(e){this.content.dirty=e}/**
     * show the scrollbar and restart the timer for fade if options.fade is set
     */activateFade(){!this.fade&&this.options.fade&&(this.scrollbar.alpha=1,this.fade={wait:this.options.fadeScrollboxWait,duration:0})}/**
     * handle pointer down on scrollbar
     * @param {PIXI.interaction.InteractionEvent} e
     * @private
     */scrollbarDown(t){const e=this.toLocal(t.data.global);return this.isScrollbarHorizontal&&e.y>this.boxHeight-this.scrollbarSize?(e.x>=this.scrollbarLeft&&e.x<=this.scrollbarLeft+this.scrollbarWidth?this.pointerDown={type:"horizontal",last:e}:e.x>this.scrollbarLeft?(this.content.left+=this.content.worldScreenWidth,this.update()):(this.content.left-=this.content.worldScreenWidth,this.update()),void(this.options.stopPropagation&&t.stopPropagation())):this.isScrollbarVertical&&e.x>this.boxWidth-this.scrollbarSize?(e.y>=this.scrollbarTop&&e.y<=this.scrollbarTop+this.scrollbarWidth?this.pointerDown={type:"vertical",last:e}:e.y>this.scrollbarTop?(this.content.top+=this.content.worldScreenHeight,this.update()):(this.content.top-=this.content.worldScreenHeight,this.update()),void(this.options.stopPropagation&&t.stopPropagation())):void 0}/**
     * handle pointer move on scrollbar
     * @param {PIXI.interaction.InteractionEvent} e
     * @private
     */scrollbarMove(t){if(this.pointerDown){if("horizontal"===this.pointerDown.type){const e=this.toLocal(t.data.global);this.content.left+=e.x-this.pointerDown.last.x,this.pointerDown.last=e,this.update()}else if("vertical"===this.pointerDown.type){const e=this.toLocal(t.data.global);this.content.top+=e.y-this.pointerDown.last.y,this.pointerDown.last=e,this.update()}this.options.stopPropagation&&t.stopPropagation()}}/**
     * handle pointer down on scrollbar
     * @private
     */scrollbarUp(){this.pointerDown=null}/**
     * resize the mask for the container
     * @param {object} options
     * @param {number} [options.boxWidth] width of scrollbox including scrollbar (in pixels)
     * @param {number} [options.boxHeight] height of scrollbox including scrollbar (in pixels)
     * @param {number} [options.scrollWidth] set the width of the inside of the scrollbox (leave null to use content.width)
     * @param {number} [options.scrollHeight] set the height of the inside of the scrollbox (leave null to use content.height)
     */resize(e){this.options.boxWidth="undefined"==typeof e.boxWidth?this.options.boxWidth:e.boxWidth,this.options.boxHeight="undefined"==typeof e.boxHeight?this.options.boxHeight:e.boxHeight,e.scrollWidth&&(this.scrollWidth=e.scrollWidth),e.scrollHeight&&(this.scrollHeight=e.scrollHeight),this.content.resize(this.options.boxWidth,this.options.boxHeight,this.scrollWidth,this.scrollHeight),this.update()}/**
     * ensure that the bounding box is visible
     * @param {number} x - relative to content's coordinate system
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */ensureVisible(e,t,o,n){this.content.ensureVisible(e,t,o,n),this._drawScrollbars()}}var List=/** @class */function(e){function t(t){var o=t.width,n=t.height,i=t.overflowX,r=void 0===i?"hidden":i,a=t.overflowY,s=void 0===a?"auto":a,p=t.cornerRadius,l=void 0===p?0:p,d=t.scrollbarSize,c=void 0===d?5:d,u=__rest(t,["width","height","overflowX","overflowY","cornerRadius","scrollbarSize"]),h=e.call(this)||this,g=h.createGraphics(0,0,o,n,l);return h.mask=g,h.box=new Scrollbox(__assign({boxWidth:o,boxHeight:n,overflowX:r,overflowY:s,scrollbarSize:c},u)),h.beginFill(16777215,0),h.drawRect(0,0,o,n),h.endFill(),h.addChild(h.box),h}return __extends(t,e),t.prototype.createGraphics=function(e,t,o,n,i,r){void 0===i&&(i=0),void 0===r&&(r=16777215);var a=new Graphics;return a.beginFill(r),a.drawRoundedRect(e,t,o,n,i),a.endFill(),a},t.prototype.push=function(e){this.box.content.addChild(e)},t}(Graphics);export default List;
//# sourceMappingURL=list.es.min.js.map
